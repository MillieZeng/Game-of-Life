Program description:
	In program description, we are going to briefly describe the functionalities we use in our code and the features they have. 
	We create four major classes, which are GameDemo, GameEngine, CellularAutomata, ArrayPatternResources. 
	ArrayPatternResources is a father class, and it has four children classes:  BlinkerPattern, BlockPattern, ExploderPattern, GliderPattern. We use the concept of inheritance in these classes, and the four children classes extend the methods from their father class. In ArrayPatternResources, we use the concept of object and create an instance called resources. There’s a constructor with an argument in ArrayPatternResources, which is used to input the game resources. And there’s a put() method which contains a nested FOR loop to put the chosen pattern into the game board.
	GameEngine is constructed with a non-args constructor, a run() method which is responsible for timer and display. In the data field, we have CellularAutomata scene to ensure that we can invoke the methods from CellularAutomata. In run() method, we use a functionality called SLEEP to execute the display operation every second because we need to determine how long it takes to refresh the display. We also use a ProcessBuilder to clean the screen after every display unless the results will be shown next by next.  
	CellularAutomata is constructed with a constructor containing an argument, a init() method, a update() method, and a print() method. In constructor we create instances of current status (boolean[][] cGrid), previous status(boolean[][] pGrid) and the board size(int boardSize). We are allowed to set the size of game board by invoking CellularAutomata with an integer. In init() method, we use a nested FOR loop to make every elements in boolean[][] cGrid FALSE. In update() method, we two nested FOR loop to do the rules of game of life. Initially, use pGrid (previous status) to save cGrid(current status) unless the status won't update. The second FOR loop is a traversal and its feature is same as countNeighbors in our homework. A new grammar we used in the second FOR loop is “condition ? result1:result2”, which means if the condition is true, we get result1, otherwise we get result2. Print() method is the classic method to print a 2D array out. Since we are creating and initializing cGrid in this class, we do a set() method to invoke the ArrayPatternResources and load resource here and enable resource to run the rules of game of life. 
	GameDemo contains the main method of the whole project, and we have scanner in it to ensure the users can choose the pattern from given choices. We invoke the methods from GameEngine, ArrayPatternResources and CellularAutomata in certain order. 
Overall Program design: 
Conway’s game of life is generated from the concept of Cellular Automata and devised by British mathematician John Horton Conway.[1] It is a model that contains time, space, and status, which is similar to a small universe. Our program combines the concept of Cellular Automata and classic game engineering structure, and create three main parts of our game: GameEngine, CellularAutomata, ArrayPatternResources. GameEngine is responsible for time control and display. ArrayPatternResources is the father class of the four children class: BlinkerPattern, BlockPattern, ExploderPattern, GliderPattern. CellularAutomata is responsible for status updating and the rules of game of life. For deep descriptions, game engine is an important part of a game architecture, and the core functions of the it includes 2D or 3D graphics rendering, animation, network, streaming media, memory management, threading, scene drawing and so on. In game of life, there’s nearly no memory management, network or streaming data and we only do 2D graphics rending, timer and scene drawing roughly. Game resources in a game architecture is responsible for managing the resources like characters, skins, and so on. In game of life, what we have for game resources are different 2D array patterns, and they can be chosen by users. Besides game engine and game resources, we need the core of game architecture, and that is the rules of a game. In our project, the rules of game of life can be considered as the core of game, and we named it CellularAutomata. Since the Game of life is a zero-player game and requires no interaction with users, the users only watch how the pattern evolves every second based on their choices and there’s no need for a specific UI class. We set scanners in game engine and the main method to ensure the users can choose their favorite game resource and generation speed (how many generations in one second). After the initial choice of speed and pattern, the pattern will automatically run the rules of game of life and will reach a static state after numbers of generations. To stop the generations, enter Ctrl + C in terminal.

Major classes: 
Class ArrayPatternResources
This is the father class of patterns designed for choosing different pattern. The user inputs a pattern (boolean[][]input), and the pattern will be copied as boolean[][]resources and then will be put in a 2D array - boolean [][] cGrid. The location can be set with r and c and we have initially set it at 15,15. The method put() is what sets the initial location of the glider in the grid at 15,15.
Class CellularAutomata
The class of CellularAutomata first initializes the grid, size of the board and sets all of the members to false as its current status. From there, the initial position of the glider is 15,15 and it is invoked from the method put() which is created in the previously discussed class (AarrayPatternResources). Further, this class counts the neighbors and updates the generations according to the rules of the Game of life. It prints the next generation. 
Class GameEngine 
It is designed for time control and display. It makes the connection between AarrayPatternResources & CellularAutomata & Game Engine by initializing a CA (CellularAutomata scene). It allows the users to input the speed and the pattern. It sets the board size -39x39. It updates the view for the user after every generation update made in CellularAutomata Class. It times the break between generations clears the user view and presents the new generation. 
Class GameDemo 
This class is only for demonstration. It contains the main method and it invokes methods from other classes in order. The class contains a Scanner method, which initiates the user input for speed and pattern then invokes the corresponding methods in the class.
Classes BlinkerPattern, BlockPattern, ExploderPattern, GliderPattern.
Each of those classes loads their specific 2D array as a resource into the father class and enables to be invoked by initializing the father class (Aarray Pattern Resources) 

UI:
User Interface is at the top of a game architecture, and it directly shows on screen. We ask the user to make 2 input choices – speed and pattern. There are 4 patterns for users to choose from: Blinkers, Block, Exploder, Glider. To implement this functionality, we set scanner in both GameEngine and GameDemo. In GameEngine, there’s a scanner which enables the users to choose the generation speed. GameDemo contains the main method and enables the users to choose their favorite pattern. 
